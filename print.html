<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RosLibRust Guides</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RosLibRust Guides</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="roslibrust-guides"><a class="header" href="#roslibrust-guides">RosLibRust Guides</a></h1>
<p>This book contains supplemental information and extended documentation for RosLibRust.</p>
<p>To get started using RosLibRust checkout the <a href="./quick_getting_started.html">Quick Getting Started</a> guide if you are comfortable with the basics of rust and ROS, otherwise checkout the <a href="./extended_getting_started.html">Extended Getting Started</a> guide for a more in depth guide that explains more of the concepts.</p>
<p>To learn about what RosLibRust is and why it was created checkout the <a href="./introduction.html">Introduction</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-getting-started"><a class="header" href="#quick-getting-started">Quick Getting Started</a></h1>
<p>Brief guide for setting up roslibrust, if you get stuck or want a more in depth guide checkout <a href="./extended_getting_started.html">Extended Getting Started</a></p>
<p>Add roslibrust as a dependency in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "example_package"
version = "0.1.0"
edition = "2021"

# What crates your code needs when built regularly (e.g. `cargo build` or `cargo run`)
[dependencies]
# Here we specify what features from roslibrust we want our main code to have access to
# We'll need at least one backend, rosbridge is shown here, but any could be substituted in
# We also need the codegen feature as the types that are generated in build.rs rely on types from codegen
roslibrust = { path = "../roslibrust", features = ["rosbridge", "codegen"] }
# We need a tokio runtime to setup our async behaviors, these are the minimum tokio features we need
tokio = { version = "1", features = ["sync", "macros"] }
# Brining in a logger to help with debugging
env_logger = "0.11"

# What crates your code needs for testing and examples
[dev-dependencies]
# Tests use the mock backend from roslibrust
roslibrust = { path = "../roslibrust", features = ["mock"] }
# Tests also use test-util to pause time
tokio = { version = "1", features = ["test-util"] }

# What crates your code needs to run it's build.rs file
[build-dependencies]
# We need the codegen feature when running build.rs to be able to actually generate the types
roslibrust = { path = "../roslibrust", features = ["codegen"] }
</code></pre>
<p>Setup a <code>build.rs</code> file to generate ROS types, and set your <code>search_paths</code> to point at your ROS messages:</p>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Define our search paths
    // Note: these currently point towards the assets folder in the roslibrust repository,
    // you'll want to point this at the location of your own .msg/.srv files
    let p = vec![
        "../assets/ros2_common_interfaces".into(),
        "../assets/ros2_required_msgs/rcl_interfaces/builtin_interfaces".into(),
    ];

    // Actually invoke code generation on our search paths.
    let (source, dependent_paths) =
        roslibrust::codegen::find_and_generate_ros_messages_without_ros_package_path(p)?;
    // This returns two things:
    // 1) A TokenStream which is the rust code we want to generate
    // 2) A list of paths that if modified would require the code to be regenerated. We use this to inform Cargo
    //    of when to re-run our build script.

    // It is important for build scripts to only output files to OUT_DIR which is an environment variable set by Cargo.
    let out_dir = std::env::var_os("OUT_DIR").unwrap();
    // Name of the file in out_dir we want to write our generated code to
    let dest_path = std::path::Path::new(&amp;out_dir).join("messages.rs");
    // Write the generated code to disk
    std::fs::write(dest_path, source.to_string())?;

    // If we stopped at this point, our code would still work, but Cargo would not know to rebuild
    // our package when a message file changed.
    // Cargo recognizes certain command line strings that build scripts print out:
    for path in &amp;dependent_paths {
        // Tell cargo to re-run our build script if any of these files change
        println!("cargo:rerun-if-changed={}", path.display());
    }

    Ok(())
}</code></pre>
<p>Write a basic generic node with tests, and profit:</p>
<pre><code class="language-rust ignore">//! This file shows how to correctly import files generated by build.rs:

// This macro trick correctly "imports" messages.rs into our crate
// This should only be invoked once in the crate and other locations can access the
// messages via `use`
include!(concat!(env!("OUT_DIR"), "/messages.rs"));

// Important to bring traits we need into scope from roslibrust
// In this case we need to the Publish trait in scope so we can access the .publish() function on our Publisher
use roslibrust::Publish;

// Writing a simple behavior that uses the generic traits from roslibrust
// and the generated types from the macro above.
async fn pub_counter(ros: impl roslibrust::Ros) {
    let publisher = ros
        .advertise::&lt;std_msgs::Int16&gt;("example_counter")
        .await
        .unwrap();
    let mut counter = 0;
    loop {
        publisher
            .publish(&amp;std_msgs::Int16 { data: counter })
            .await
            .unwrap();
        println!("Published {counter}");
        counter += 1;
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    }
}

// Our actual "main" here doesn't do much, just shows the generate types
// are here and real.
#[tokio::main]
async fn main() {
    // Create a rosbridge client we can use
    let ros = roslibrust::rosbridge::ClientHandle::new("ws://localhost:9090")
        .await
        .unwrap();
    // Start our behavior while waiting for ctrl_c
    tokio::select! {
        _ = pub_counter(ros) =&gt; {}
        _ = tokio::signal::ctrl_c() =&gt; {}
    }
}

// Setup a test of our pub_counter behavior
#[cfg(test)]
mod test {
    use super::*;
    use roslibrust::{Subscribe, TopicProvider};

    #[tokio::test]
    async fn test_pub_counter() {
        // See: https://tokio.rs/tokio/topics/testing
        // This test doesn't take 1 second to run even thou it looks like it should!
        // Tokio simulates time in tests if you call pause()
        // This test takes 0.00s to run on a reasonable machine
        tokio::time::pause();
        let ros = roslibrust::mock::MockRos::new();

        // Subscribe to the topic we're publishing to
        let mut subscriber = ros
            .subscribe::&lt;std_msgs::Int16&gt;("example_counter")
            .await
            .unwrap();

        // Start publishing in the background
        tokio::spawn(async move { pub_counter(ros).await });

        // Confirm we get the first message
        let msg = subscriber.next().await.unwrap();
        assert_eq!(msg.data, 0);

        // Confirm second message quickly times out
        let msg =
            tokio::time::timeout(tokio::time::Duration::from_millis(10), subscriber.next()).await;
        assert!(msg.is_err());

        // Wait a bit
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        // Now get second message
        let msg = subscriber.next().await.unwrap();
        assert_eq!(msg.data, 1);
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Inside the roslibrust repository you'll find <a href="https://github.com/RosLibRust/roslibrust/tree/master/example_package">example_package</a>
and <a href="https://github.com/RosLibRust/roslibrust/tree/master/example_package_macro">example_package_macro</a> which serve as good examples of how to integrate roslibrust into a package.</p>
<p>This documentation walks you through how those packages are setup, and how to get started using RosLibRust in your own project.</p>
<p>We recommend using the build.rs approach shown in example_package, as this approach will automatically re-generate your ROS types when the underlying .msg/.srv files are changed.
The macro approach shown in example_package_macro is easier to setup, but can't detect when the underlying .msg/.srv files are changed.
This approach is fine to use if you know your .msg/.srv files are not changing, or if you are ok with manually re-running the macro to generate the types.</p>
<p>This tutorial is written for someone who is new to both Rust and ROS, and assumes no prior knowledge of either.</p>
<h2 id="machine-setup"><a class="header" href="#machine-setup">Machine Setup</a></h2>
<p>RosLibRust is currently only actively tested on Linux, however it should work on Windows and MacOS as well.
If you run into any issues on Windows or MacOS please open an issue on the <a href="https://github.com/RosLibRust/roslibrust/issues">roslibrust github</a>.</p>
<p>The only requirement to building roslibrust is the rust compiler and toolchain.</p>
<p>These are best installed via the instructions on the <a href="https://www.rust-lang.org/tools/install">rust website</a>.</p>
<p>If you are using Linux you can install the rust toolchain by running:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>RosLibRust currently requires a version of the Rust compiler greater than 1.85. This can be checked by running <code>rustc --version</code>.</p>
<p>If you can run this command and see a version greater than 1.85 you're good to move on to the next step.</p>
<p>For actually running the example applications show here you'll need a working ROS installation with the <code>rosbridge_server</code> package.
These instructions show using docker images to run isolated ROS environments.
To exactly follow these instructions you'll need <code>docker engine</code> installed and running on your system.
However, docker can by bypassed if you prefer to directly install a specific version of ROS on your system.</p>
<p>To install docker engine see the <a href="https://docs.docker.com/engine/install/">docker website</a>.</p>
<h2 id="making-an-empty-project"><a class="header" href="#making-an-empty-project">Making an Empty Project</a></h2>
<p>For a longer explanation of this section see the <a href="https://doc.rust-lang.org/book/ch01-03-hello-cargo.html">Hello Cargo</a> section of the Rust Book.</p>
<p>In a folder of your choice run <code>cargo new my_package</code>. This will create a new rust package in the <code>my_package</code> folder.</p>
<p>Cargo (rust's build tool) will automatically generate several files for you in this directory:</p>
<pre><code class="language-bash">my_package
├── .git # A git repository is automatically created for you. You should use git!
├── .gitignore # A gitignore file is automatically created for you with good defaults for a Rust project.
├── Cargo.toml # Controls dependencies and other metadata for your package, equivalent to CMakeLists.txt in C++ or package.xml in ROS
└── src # All the "main" code for your package lives in this folder
    └── main.rs # A starting file with some initial code in it
</code></pre>
<p>Now that we've created this project we can:</p>
<pre><code class="language-bash"># Change into the directory of our new package.
# Once we've done this cargo commands will automatically detect the Cargo.toml file and know
# that they should operate on this package
cd my_package
# This command with both fully compile our package and all its dependencies, and then run the
# resulting executable
cargo run
</code></pre>
<p>If you see <code>Hello, world!</code> printed to the console you're good to move on to the next step.</p>
<h2 id="setting-up-cargotoml"><a class="header" href="#setting-up-cargotoml">Setting Up Cargo.toml</a></h2>
<p>To use roslibrust we need to modify <code>Cargo.toml</code> to add roslibrust as a dependency.</p>
<p>If you're new to Rust you should checkout this chapter in the Cargo Book: <a href="https://doc.rust-lang.org/cargo/guide/dependencies.html">Dependencies</a></p>
<p>An example <code>Cargo.toml</code> is:</p>
<pre><code class="language-toml">[package]
name = "my_package"
version = "0.1.0"
edition = "2021"

# What crates your code needs when built regularly (e.g. `cargo build` or `cargo run`)
[dependencies]
# You will need to specify at least one backend to use with roslibrust, available options are [ros1, rosbridge, zenoh, mock] (ros2 is coming soon)
# You will also need to specify the "codegen" feature, as the generated ROS types rely on features from this module
roslibrust = { version = "0.15", features = ["rosbridge", "codegen"] }
# RosLibRust is built on tokio, and requires a multi-threaded tokio runtime.
# You don't need the "full" tokio feature set, but it is a good starting place
tokio = { version = "1", features = ["full"] }

# What crates your code needs for testing and examples
[dev-dependencies]
# For testing you'll want to use the "mock" backend if you specify it here, it won't affect your production builds
roslibrust = { version = "0.15", features = ["mock"] }
tokio = { version = "1", features = ["test-util"] }

# What crates your code needs to run it's build.rs file
[build-dependencies]
# In build.rs we'll use roslibrust's codegen features to generate Rust types from ROS .msg/.srv files
roslibrust = { version = "0.15", features = ["codegen"] }
</code></pre>
<p>Once we've modified <code>Cargo.toml</code> in this way we can run <code>cargo build</code>,
and we should see Cargo automatically download and compile all the dependencies we've specified.</p>
<p>If this works you're ready to move on to the next step.</p>
<h2 id="setting-up-automatic-rust-ros-type-generation"><a class="header" href="#setting-up-automatic-rust-ros-type-generation">Setting Up Automatic Rust&lt;-&gt;ROS Type Generation</a></h2>
<p>In ROS based systems "nodes" communicate with each other by sending and receiving messages.
Because ROS supports multiple languages (Python, C++, Rust, etc.) a common schema language was needed.
ROS uses calls these custom message definitions "Interfaces" and documents them <a href="https://docs.ros.org/en/rolling/Concepts/Basic/About-Interfaces.html">in the ROS documentation's Basic Concepts section</a>.</p>
<p>To work ergonomically in Rust with these messages we want a corresponding Type in Rust for each message type.
RosLibRust will automatically generate these types for us, and uses the generate types to serialize and deserialize messages as they are sent and received.</p>
<p>To setup automatic generation of these Rust types from ROS interface files, we'll leverage Rust's build.rs feature.
A <code>build.rs</code> file is a special file that Cargo will automatically run before compiling your crate.
This file can be used to generate code, compile native dependencies, or perform any other task needed to build your crate.
Learn more about writing <code>build.rs</code> files <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">in the Cargo Book's build scripts section</a>.</p>
<p>Let's create a copy of build.rs file from <a href="https://github.com/RosLibRust/roslibrust/tree/master/example_package">example_package</a> in our package:</p>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Define our search paths
    // Note: these currently point towards the assets folder in the roslibrust repository,
    // you'll want to point this at the location of your own .msg/.srv files
    let p = vec![
        "../assets/ros2_common_interfaces".into(),
        "../assets/ros2_required_msgs/rcl_interfaces/builtin_interfaces".into(),
    ];

    // Actually invoke code generation on our search paths.
    let (source, dependent_paths) =
        roslibrust::codegen::find_and_generate_ros_messages_without_ros_package_path(p)?;
    // This returns two things:
    // 1) A TokenStream which is the rust code we want to generate
    // 2) A list of paths that if modified would require the code to be regenerated. We use this to inform Cargo
    //    of when to re-run our build script.

    // It is important for build scripts to only output files to OUT_DIR which is an environment variable set by Cargo.
    let out_dir = std::env::var_os("OUT_DIR").unwrap();
    // Name of the file in out_dir we want to write our generated code to
    let dest_path = std::path::Path::new(&amp;out_dir).join("messages.rs");
    // Write the generated code to disk
    std::fs::write(dest_path, source.to_string())?;

    // If we stopped at this point, our code would still work, but Cargo would not know to rebuild
    // our package when a message file changed.
    // Cargo recognizes certain command line strings that build scripts print out:
    for path in &amp;dependent_paths {
        // Tell cargo to re-run our build script if any of these files change
        println!("cargo:rerun-if-changed={}", path.display());
    }

    Ok(())
}</code></pre>
<p>Before this build.rs script can run successfully we'll need to give it some real ROS messages to find.
For this example we'll use some standard ROS2 messages from the <a href="https://github.com/ros2/common_interfaces">ROS2 Common Interfaces</a> repository.</p>
<p>To clone these messages into our package we can run:</p>
<pre><code class="language-bash"># Make sure we're in the root of our package
cd my_package
# Make a folder to hold our messages
mkdir assets
# Clone the common interfaces into that folder
git submodule add https://github.com/ros2/common_interfaces assets/common_interfaces
</code></pre>
<div class="warning">
<p>Warning: ROS messages can refer to other messages in their contents.
For example many messages include a <code>Header</code> message from the <code>std_msgs</code> package.
For code generation to work correctly you must include all the messages you want to generate, AND all the messages that those messages depend on.</p>
</div>
<p>In this specific case, the messages in <code>common_interfaces</code> rely on messages from the <code>builtin_interfaces</code> which is not included in
that same repository. To fix this we'll also need to clone the <code>rcl_interfaces</code> repository which contains the <code>builtin_interfaces</code> package:</p>
<pre><code class="language-bash"># Make sure we're in the root of our package
cd my_package
# Clone the rcl_interfaces repository into our assets folder
git submodule add https://github.com/ros2/rcl_interfaces assets/rcl_interfaces
</code></pre>
<p>Now we just need to modify the <code>search_paths</code> variable in our <code>build.rs</code> file to point at our new messages:</p>
<pre><code class="language-rust ignore">let search_paths = vec![
    "assets/common_interfaces".into(),
    "assets/rcl_interfaces/builtin_interfaces".into(),
];</code></pre>
<p>Now if we run <code>cargo build</code> again we should see Cargo automatically run our <code>build.rs</code> file, and generate our Rust types from the ROS messages.
This won't be immediately obvious from the command line, but we can go look in the <code>target</code> folder of our package to see the generated code.
The generated code will be in <code>target/debug/build/my_package-&lt;some hash of our package&gt;/out/messages.rs</code>.</p>
<p>We can check if the file exists by running:</p>
<pre><code class="language-bash">find -name "messages.rs"
</code></pre>
<p>If this prints out a path to a <code>messages.rs</code> file we're good to move on to the next step.</p>
<h2 id="using-generated-types"><a class="header" href="#using-generated-types">Using Generated Types</a></h2>
<p>Now that we've generated our types we can use them in our code.
Rust luckily has some convenient macros for bringing generated code "into scope" for a crate.</p>
<p>If we open up <code>src/main.rs</code> and add the following line at the top of the file:</p>
<pre><code class="language-rust ignore">include!(concat!(env!("OUT_DIR"), "/messages.rs"));</code></pre>
<p>It will automatically find the generated <code>messages.rs</code> and effectively "copy paste" the contents of that file into our <code>main.rs</code> file.</p>
<p>Breaking down how that line works:</p>
<ul>
<li><code>env!("OUT_DIR")</code> is a macro that expands to the value of the <code>OUT_DIR</code> environment variable. This is set by Cargo and points to the folder where our generated code is located.</li>
<li><code>concat!(...)</code> is a macro that concatenates multiple string literals into a single string literal. In this case we're concatenating the <code>OUT_DIR</code> environment variable with the path to our generated code.</li>
<li><code>include!(...)</code> is a macro that includes the contents of the file at the specified path into the current file. In this case we're including the generated <code>messages.rs</code> file into our <code>main.rs</code> file.</li>
</ul>
<p>Once we've added that line to <code>main.rs</code> all our generated messages will be available to us in the rest of our code.</p>
<p>For this example we'll keep it simple and leave that line in <code>main.rs</code>, but in larger projects it is recommended to move the generated types to either a msgs module or a separate msgs crate in a workspace.</p>
<h2 id="writing-our-first-node"><a class="header" href="#writing-our-first-node">Writing Our First Node</a></h2>
<p>You're now ready to actually write some code that uses RosLibRust!</p>
<p>We're going to start with a basic example of publishing to a topic.</p>
<p>Modify <code>src/main.rs</code> to look like the following:</p>
<pre><code class="language-rust ignore">// Bring generated messages into scope:
include!(concat!(env!("OUT_DIR"), "/messages.rs"));

// Bring in traits we need from roslibrust
use roslibrust::traits::{Publish, Ros, Subscribe};

use std::sync::Arc;
use tokio::sync::Mutex;

// Writing a simple publisher behavior using roslibrust's generic traits
async fn pub_counter(ros: impl Ros, state: Arc&lt;Mutex&lt;u32&gt;&gt;) {
    // This will nicely control the rat our code runs at
    let mut interval = tokio::time::interval(std::time::Duration::from_secs(1));
    // Create a publisher on our topic
    let publisher = ros
        .advertise::&lt;std_msgs::UInt32&gt;("/example_counter")
        .await
        .expect("Could not create publisher!");

    loop {
        // Wait for next tick of our interval timer
        interval.tick().await;

        // Lock our state and read the current value
        let cur_val = *state.lock().await;

        // Publish the current value
        publisher
            .publish(&amp;std_msgs::UInt32 { data: cur_val })
            .await
            .expect("Failed to publish message!");

        // Increment our state
        *state.lock().await += 1;
    }
}

// This macro sets up a basic tokio runtime for us and lets our main function be `async`
#[tokio::main]
async fn main() {
    // Initialize a logger to help with debugging
    env_logger::init();

    // Create a rosbridge client we can use
    let ros = roslibrust::rosbridge::ClientHandle::new("ws://localhost:9090")
        .await
        .expect("Failed to connect to rosbridge!");

    // Create a shared state we can use to track our counter
    let publisher_state = Arc::new(Mutex::new(0));

    // Spawn a new tokio task to run our publisher:
    tokio::spawn(pub_counter(ros, publisher_state));

    // Wait for ctrl_c
    tokio::signal::ctrl_c().await.unwrap();
}</code></pre>
<p>There is a lot to break down in this example, it uses many of the features of Rust, Tokio, and RosLibRust.</p>
<p>Let's start with the high level structure:</p>
<ul>
<li>Our "node" is defined in an <code>async fn</code> this allows to spawn an instance of our node as a new tokio task.</li>
<li>Our node uses <code>impl Ros</code> for the type of the <code>ros</code> parameter. This makes the function generic over any roslibrust backend.</li>
<li>Our main function sets up the dependencies of our node, and then spawns it as a new tokio task to run independently.</li>
<li>We use <code>Arc&lt;Mutex&lt;&gt;&gt;</code> to share mutable state between our tokio tasks.</li>
</ul>
<p>Right now, <strong>why</strong> we did all these things might not be obvious, but it will be once we start wanting to write more complex nodes and when we want to test those nodes.</p>
<h2 id="running-our-node"><a class="header" href="#running-our-node">Running Our Node</a></h2>
<p>So far we've avoided installing any version of ROS at all. This is great since we can write and run our node on a system without any ROS
making our code extremely portable. However, to actually run our node we'll want a ROS system to connect to.</p>
<p>One way to setup this up would be to go through a full ROS installation for either <code>ROS1</code> or <code>ROS2</code>, but the recommended approach for roslibrust is use a ROS installation inside a docker container.
This unfortunately introduces the complexity of docker, but it is a very portable and repeatable way to setup a ROS environment.
Furthermore, it makes it extremely easy to experiment with multiple versions of ROS!</p>
<p>ROS provides docker images for both ROS1 and ROS2 on their <a href="https://hub.docker.com/_/ros">dockerhub page</a>.</p>
<p>RosLibRust is publishing extended docker images that include a rust installation and the <code>rosbridge_server</code> package.
We use these images for developing RosLibRust, and to run our CI tests.</p>
<p>To startup a ROS2 kilted rosbridge server you can run the following commands:</p>
<pre><code class="language-bash"># This will startup a docker container with everything installed in it and drop you into a bash shell inside of the container
docker run -it --network host carter12s/roslibrust-ci-kilted:latest bash
# This will now activate the ROS2 installation inside the container
source /opt/ros/kilted/setup.bash
# This will start up the ROS2 zenoh router, and leave it running in the background
ros2 run rmw_zenoh_cpp rmw_zenohd &amp; disown
# This will start the rosbridge server on the default port of 9090
ros2 run rosbridge_server rosbridge_websocket
</code></pre>
<p>Now in a separate terminal we can run our node.
To be able to actually see what our node is doing we'll enable debug logging with the <code>RUST_LOG</code> environment variable (<a href="https://docs.rs/env_logger/latest/env_logger/">more info on RUST_LOG</a>):</p>
<pre><code class="language-bash">RUST_LOG=debug cargo run
</code></pre>
<p>We should now see our terminal output something like:</p>
<pre><code class="language-txt">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.15s
     Running `/home/carter/roslibrust/target/debug/examples/getting_started_1`
[2025-09-21T19:39:54Z DEBUG roslibrust_rosbridge::client] Starting a stubborn_connect attempt to ws://localhost:9090
[2025-09-21T19:39:54Z DEBUG tungstenite::handshake::client] Client handshake done.
[2025-09-21T19:39:54Z DEBUG roslibrust_rosbridge::client] Starting stubborn_spin
[2025-09-21T19:39:54Z DEBUG roslibrust_rosbridge::client] Advertise got lock on comm
[2025-09-21T19:39:54Z DEBUG roslibrust_rosbridge::comm] Sending advertise: Text("{\"op\":\"advertise\",\"topic\":\"/example_counter\",\"type\":\"std_msgs/UInt32\"}")
[2025-09-21T19:39:54Z DEBUG roslibrust_rosbridge::client] Publish got write lock on comm
[2025-09-21T19:39:54Z DEBUG roslibrust_rosbridge::comm] Sending publish: Text("{\"msg\":{\"data\":0},\"op\":\"publish\",\"topic\":\"/example_counter\",\"type\":\"std_msgs/UInt32\"}")
[2025-09-21T19:39:55Z DEBUG roslibrust_rosbridge::client] Publish got write lock on comm
</code></pre>
<p>We can also confirm everything is working by looking at the output of the rosbridge server in our other terminal.
We should see a "Client connected" message when we startup our node and a "Client disconnected" message when we ctrl+c out of our node.</p>
<pre><code class="language-txt">[INFO] [1758483594.506878271] [rosbridge_websocket]: Client connected. 1 clients total.
[INFO] [1758483600.897845391] [rosbridge_websocket]: Client disconnected. 0 clients total.
</code></pre>
<h2 id="extending-our-node-to-subscribe"><a class="header" href="#extending-our-node-to-subscribe">Extending Our Node to Subscribe</a></h2>
<p>Let's have our node now subscribe to its same topic, and "talk to itself".</p>
<p>Along side our <code>pub_counter</code> let's add a <code>sub_counter</code> function:</p>
<pre><code class="language-rust ignore">async fn sub_counter(ros: impl Ros, state: Arc&lt;Mutex&lt;u32&gt;&gt;) {
    // Create a subscriber on our topic
    let mut subscriber = ros
        .subscribe::&lt;std_msgs::UInt32&gt;("/example_counter")
        .await
        .expect("Could not create subscriber!");

    loop {
        // Wait for next message
        let msg = subscriber.next().await.expect("Failed to get message!");

        // Print the message
        println!("Got message: {}", msg.data);

        // Decrement our state
        *state.lock().await -= 1;
    }
}</code></pre>
<p>And then we'll modify our <code>main</code> function to spawn both behaviors:</p>
<pre><code class="language-rust ignore">// This macro sets up a basic tokio runtime for us and lets our main function be `async`
#[tokio::main]
async fn main() {
    // Initialize a logger to help with debugging
    env_logger::init();

    // Create a rosbridge client we can use
    let ros = roslibrust::rosbridge::ClientHandle::new("ws://localhost:9090")
        .await
        .expect("Failed to connect to rosbridge!");

    // Create a shared state we can use to track our counter
    let shared_state = Arc::new(Mutex::new(0));

    // Spawn a new tokio task to run our publisher:
    tokio::spawn(pub_counter(ros.clone(), shared_state.clone()));

    // Spawn a new tokio task to run our subscriber:
    tokio::spawn(sub_counter(ros, shared_state.clone()));

    // Wait for ctrl_c
    tokio::signal::ctrl_c().await.unwrap();
}</code></pre>
<p>Note: you can now see that we're calling <code>.clone()</code> on our <code>ros</code> and <code>state</code> variables when we spawn our tasks.
For both of these variables, that creates an additional "handle" to the underlying data that can be owned by the new task.
Previously, we we're <code>moving</code> ownership of these variables into our <code>pub_counter</code> task, but now that we want to use them in multiple tasks we need to clone them.</p>
<p>When we run this example (with our docker image still up in the background) we'll see logging like:</p>
<pre><code class="language-txt">[2025-09-21T19:49:30Z DEBUG roslibrust_rosbridge::client] Publish got write lock on comm
[2025-09-21T19:49:30Z DEBUG roslibrust_rosbridge::comm] Sending publish: Text("{\"msg\":{\"data\":0},\"op\":\"publish\",\"topic\":\"/example_counter\",\"type\":\"std_msgs/UInt32\"}")
[2025-09-21T19:49:30Z DEBUG roslibrust_rosbridge::client] Got message: Text("{\"op\": \"publish\", \"topic\": \"/example_counter\", \"msg\": {\"data\": 0}}")
[2025-09-21T19:49:30Z DEBUG roslibrust_rosbridge::client] got message: {"op": "publish", "topic": "/example_counter", "msg": {"data": 0}}
Got message: 0
</code></pre>
<h2 id="writing-tests-for-our-node"><a class="header" href="#writing-tests-for-our-node">Writing Tests for Our Node</a></h2>
<p>Being able to unit and integration test our ROS code is a major feature of RosLibRust.
Let's now ensure our <code>pub_counter</code> and <code>sub_counter</code> behaviors work together in a test.</p>
<p>At the end of <code>main.rs</code> add the following:</p>
<pre><code class="language-rust ignore">// cfg(test) here means that this code is only compile when invoking `cargo test` and doesn't get included in normal builds
#[cfg(test)]
mod test {
    // Bring pub_counter and sub_counter into scope
    use super::*;

    // Tokio will automatically set up an individual async runtime for this test
    #[tokio::test]
    async fn test_pub_sub_counter() {
        // To let us see how long the test takes to run record the current time
        let tick = std::time::SystemTime::now();
        // MAGIC HERE:
        tokio::time::pause();

        // Create a mock ros instance we can use
        // This instance of ROS is unique to this test and won't interfere with any other tests running parallel
        let ros = roslibrust::mock::MockRos::new();

        // Creating separate states so we can inspect individually how they change
        let publisher_state = Arc::new(Mutex::new(0));
        let subscriber_state = Arc::new(Mutex::new(10));

        // Spawn a new tokio task to run our publisher:
        tokio::spawn(pub_counter(ros.clone(), publisher_state.clone()));
        // Spawn a new tokio task to run our subscriber:
        tokio::spawn(sub_counter(ros, subscriber_state.clone()));

        // The publisher and subscriber run for a bit in the background
        tokio::time::sleep(std::time::Duration::from_secs(10)).await;
        let published_count = *publisher_state.lock().await;
        let subscribed_count = *subscriber_state.lock().await;
        // Check the exact number of messages our publisher and subscriber got
        assert_eq!(
            published_count, 10,
            "Published count should be 10, but was {published_count}"
        );
        assert_eq!(
            subscribed_count, 0,
            "Subscribed count should be 0, but was {subscribed_count}"
        );
        // Purely for demonstration purposes, show how long this test takes to run
        let tock = std::time::SystemTime::now();
        println!("Test took in realtime {:?}", tock.duration_since(tick));
    }
}</code></pre>
<p>To understand this test you should first read Tokio's <a href="https://tokio.rs/tokio/topics/testing">testing guide</a>.</p>
<p>The key points are:</p>
<ul>
<li>Tokio's runtime can tell when all futures are block on "time pasing"</li>
<li>When this happens it can determine which future will complete "soonest"</li>
<li>It can then "fast forward" time to that point and poll all futures again</li>
<li>This allows us to deterministically test our code that is driven by time "as fast as possible"</li>
</ul>
<p>We can run this test with <code>cargo test</code> and see the following:</p>
<pre><code class="language-txt">running 1 test
test test::test_pub_counter ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>If we want to see what our test prints to the terminal we can run <code>cargo test -- --no-capture</code> and see the following:</p>
<pre><code class="language-txt">running 1 test
Got message: 0
Got message: 1
Got message: 2
Got message: 3
Got message: 4
Got message: 5
Got message: 6
Got message: 7
Got message: 8
Got message: 9
Test took in realtime Ok(167.189µs)
test test::test_pub_sub_counter ... ok
</code></pre>
<p>This test takes only 167 microseconds to run! This is because Tokio is able to deterministically fast forward time to the point where our futures will complete.</p>
<h2 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h2>
<p>In this tutorial we've shown:</p>
<ul>
<li>How to setup a new crate to use roslibrust</li>
<li>How to write generic ROS behaviors that can be tested in isolation and use any ROS backend</li>
<li>How to run our node against a real ROS system using docker</li>
<li>How to write a simple integration test that uses the mock ROS backend to test multiple behaviors together</li>
</ul>
<p>After this you should have a good understanding of how to use RosLibRust to build and test ROS nodes in rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>RosLibRust is an alternative to the various existing ROS clients.
RosLibRust may be a great fit for your project, or you may benefit from one of the other existing clients.</p>
<ul>
<li><a href="https://github.com/ros2-rust/ros2_rust">ros2rust</a> is ideal if you want to release ROS2 packages to the community, or want to add Rust to an existing ROS2 project. But requires a full ROS2 installation.</li>
<li><a href="https://github.com/adnanademovic/rosrust">rosrust</a> is a solid ROS1 option, but doesn't support <code>async</code> and is un-maintained.</li>
<li><a href="https://docs.rs/ros2-client/latest/ros2_client/">ros2_client</a> is a pure rust client for ROS2 that supports <code>async</code>. However, it can only talk DDS and not Zenoh that ROS2 is migrating to.</li>
</ul>
<p>RosLibRust is ideal for systems like facility control systems and cloud tools that need to interact with a variety of ROS systems, and don't want to "become ROS" themselves.
RosLibRust has one API that supports a broad range of ROS versions and protocols.</p>
<h2 id="why-was-roslibrust-created"><a class="header" href="#why-was-roslibrust-created">Why was RosLibRust created?</a></h2>
<p>RosLibRust was designed to help solve several challenges in the ROS ecosystem:</p>
<ol>
<li>The need for <code>async</code> clients. At the time RosLibRust was written there was no <code>async</code> for ROS1 at all.</li>
<li>The need for pure rust clients.
<ol>
<li>RosLibRust nodes can be built on a system with only a rust compiler. Official rust docker images are <a href="https://hub.docker.com/_/rust">~500mb</a>.</li>
<li>Once compiled a RosLibRust node is a fully statically linked executable that can be run on any system. A RosLibRust ros1 publisher node is &lt;10MB compiled and can be deployed in 5MB alpine docker image. Show me any other ROS node that I can deploy in &lt;15 MB of size.</li>
</ol>
</li>
<li>The ROS1 -&gt; ROS2 migration was painful. While many concepts in ROS remained very similar, the API and build changes were invasive. A API abstraction layer should have made this easier.</li>
<li>ROS is pretty painful for both Unit and Integration testing.</li>
</ol>
<h2 id="how-does-roslibrust-solve-these-problems"><a class="header" href="#how-does-roslibrust-solve-these-problems">How does RosLibRust solve these problems?</a></h2>
<p>At a high level what RosLibRust provides is:</p>
<ul>
<li><a href="introduction.html#an-abstract-api-for-ros">An abstract API for ROS</a></li>
<li><a href="introduction.html#backend-implementations">Implementations of the abstract API for ROS1, ROS2, and rosbridge</a></li>
<li><a href="introduction.html#mock-implementation-for-testing">A mock implementation of ROS for testing that allows deterministic "time traveling" tests</a></li>
<li><a href="introduction.html#pure-rust-type-generation">Pure rust generation of types from ROS's .msg/.srv files that is ROS version agnostic</a></li>
</ul>
<p>These combine to make RosLibRust a powerful tool for building ROS nodes in rust.</p>
<h3 id="an-abstract-api-for-ros"><a class="header" href="#an-abstract-api-for-ros">An Abstract API for ROS</a></h3>
<p>At the heart of RosLibRust is a set of traits that define the API for interacting with ROS.
These traits are defined in the <a href="https://docs.rs/roslibrust_common/latest/roslibrust_common/">roslibrust_common</a> crate.</p>
<p>The most core trait is called <a href="https://docs.rs/roslibrust_common/latest/roslibrust_common/traits/trait.Ros.html">Ros</a>:</p>
<pre><code class="language-rust ignore">/// Represents all "standard" ROS functionality generically supported by roslibrust
///
/// Implementors of this trait behave like typical ROS node handles.
/// Cloning the handle does not create additional underlying connections, but instead simply returns another handle
/// to interact with the underlying node.
///
/// Implementors of this trait are expected to be "self de-registering", when the last node handle for a given
/// node is dropped, the underlying node is expected to be shut down and clean-up after itself
pub trait Ros: 'static + Send + Sync + TopicProvider + ServiceProvider + Clone {}</code></pre>
<p>This trait was designed to mimic how "Node Handles" work.
Breaking down this trait:</p>
<ul>
<li><code>'static</code> - Something implementing this trait holds no references to non-static data. Making its lifetime very safe.</li>
<li><code>Send</code> + <code>Sync</code> - Something implementing this trait is safe to send and <em>use</em> between threads.</li>
<li><code>Clone</code> - Something implementing this trait can be cloned, this allows us to make more handles and distribute them amongst our node.</li>
<li><code>TopicProvider</code> - Is another trait in roslibrust that allows us to create publishers and subscribers.</li>
<li><code>ServiceProvider</code> - Is another trait in roslibrust that allows us to create service clients and servers.</li>
</ul>
<p>Taking a look at the <a href="https://docs.rs/roslibrust_common/latest/roslibrust_common/traits/trait.TopicProvider.html">TopicProvider</a> trait:</p>
<pre><code class="language-rust ignore">/// This trait generically describes the capability of something to act as an async interface to a set of topics
///
/// This trait is largely based on ROS concepts, but could be extended to other protocols / concepts.
/// Fundamentally, it assumes that topics are uniquely identified by a string name (likely an ASCII assumption is buried in here...).
/// It assumes topics only carry one data type, but is not expected to enforce that.
/// It assumes that all actions can fail due to a variety of causes, and by network interruption specifically.
pub trait TopicProvider {
    // These associated types makeup the other half of the API
    // They are expected to be "self-deregistering", where dropping them results in unadvertise or unsubscribe operations as appropriate
    // We require Publisher and Subscriber types to be Send + 'static so they can be sent into different tokio tasks once created
    type Publisher&lt;T: RosMessageType&gt;: Publish&lt;T&gt; + Send + 'static;
    type Subscriber&lt;T: RosMessageType&gt;: Subscribe&lt;T&gt; + Send + 'static;

    /// Advertises a topic to be published to and returns a type specific publisher to use.
    ///
    /// The returned publisher is expected to be "self de-registering", where dropping the publisher results in the appropriate unadvertise operation.
    fn advertise&lt;T: RosMessageType&gt;(
        &amp;self,
        topic: &amp;str,
    ) -&gt; impl Future&lt;Output = Result&lt;Self::Publisher&lt;T&gt;&gt;&gt; + Send;

    /// Subscribes to a topic and returns a type specific subscriber to use.
    ///
    /// The returned subscriber is expected to be "self de-registering", where dropping the subscriber results in the appropriate unsubscribe operation.
    fn subscribe&lt;T: RosMessageType&gt;(
        &amp;self,
        topic: &amp;str,
    ) -&gt; impl Future&lt;Output = Result&lt;Self::Subscriber&lt;T&gt;&gt;&gt; + Send;
}</code></pre>
<p>We see a fairly advanced trait by Rust standards, with the following key features:</p>
<ul>
<li>We leverage Rust's <a href="https://blog.logrocket.com/using-rust-gats-improve-code-app-performance/">Generic Associated Types (GATs)</a> to define the Publisher and Subscriber types returned by the trait functions.
This means that the type (including the size) that a given implementation returns is completely different from other implementations.
The only requirement is the type implements the <a href="https://docs.rs/roslibrust_common/latest/roslibrust_common/traits/trait.Publish.html">Publish</a> and <a href="https://docs.rs/roslibrust_common/latest/roslibrust_common/traits/trait.Subscribe.html">Subscribe</a> traits.</li>
<li>While at first glance they might not look like it. The <code>advertise</code> and <code>subscribe</code> functions are actually <code>async fn</code> and return Futures.
This means we don't have to block our application on waiting for a connection to be established.</li>
<li>The advertise and subscribe functions are further generic over the message type. This is familiar to ROS users, but further compounds the complexity of the trait.</li>
</ul>
<p>To finish the chain let's look at one more trait, <a href="https://docs.rs/roslibrust_common/latest/roslibrust_common/traits/trait.Publish.html">Publish</a>:</p>
<pre><code class="language-rust ignore">/// Indicates that something is a publisher and has our expected publish
/// Implementors of this trait are expected to auto-cleanup the publisher when dropped
pub trait Publish&lt;T: RosMessageType&gt; {
    // Note: this is really just syntactic de-sugared `async fn`
    // However see: https://blog.rust-lang.org/2023/12/21/async-fn-rpit-in-traits.html
    // This generates a warning is rust as of writing due to ambiguity around the "Send-ness" of the return type
    // We only plan to work with multi-threaded work stealing executors (e.g. tokio) so we're manually specifying Send
    fn publish(&amp;self, data: &amp;T) -&gt; impl Future&lt;Output = Result&lt;()&gt;&gt; + Send;
}</code></pre>
<p>Publish finally provides the <code>publish</code> function that we use to send messages on a topic, which is again <code>async</code> and generic over the message type.
The combination of these traits is fairly complicated, but at the end of the day enables us to write code that is extremely agnostic to the underlying ROS implementation.
Furthermore, there is <strong>NO PERFORMANCE PENALTY</strong> for this abstraction.
Due to how monomorphic generics work in rust the compiler is able to completely erase the generic types at compile time, and optimize the code as if we had written it directly for the specific type.</p>
<p>What's the catch? Slightly worse compile times, but you only pay for what you use.
If you create a generic node that uses the <code>Ros</code> trait, and use it with multiple backend implementations,
there will be separate compilations of the node for each backend.</p>
<h3 id="backend-implementations"><a class="header" href="#backend-implementations">Backend Implementations</a></h3>
<p>Okay so RosLibRust has this abstract API? How can we actually use it?</p>
<p>RosLibRust provides several implementations of the <code>Ros</code> trait:</p>
<ul>
<li><a href="https://docs.rs/roslibrust_ros1/latest/roslibrust_ros1/">roslibrust_ros1</a> - Implements the TCPROS protocol that was the backbone of ROS1</li>
<li><a href="https://docs.rs/roslibrust_zenoh/latest/roslibrust_zenoh/">roslibrust_zenoh</a> - Implements a variant of ROS1 communication used by <a href="https://github.com/eclipse-zenoh/zenoh-plugin-ros1">zenoh-ros1-bridge</a></li>
<li><a href="https://docs.rs/roslibrust_rosbridge/latest/roslibrust_rosbridge/">roslibrust_rosbridge</a> - Implements the <a href="https://github.com/RobotWebTools/rosbridge_suite">rosbridge_suite</a> websocket protocol</li>
<li>COMING SOON <a href="https://docs.rs/roslibrust_ros2/latest/roslibrust_ros2/">roslibrust_ros2</a> - Implements the Zenoh communication used by <a href="https://github.com/ros2/rmw_zenoh">rmw_zenoh</a> in ROS2 from Kilted onwards</li>
<li><a href="https://docs.rs/roslibrust_mock/latest/roslibrust_mock/">roslibrust_mock</a> - Implements a mock ROS perfect for testing</li>
</ul>
<p>Typically we don't depend on these crates directly, but instead use them by enabling their corresponding features on <code>roslibrust</code>.</p>
<pre><code class="language-toml">[dependencies]
roslibrust = { version = "0.15", features = ["ros1"] }
</code></pre>
<p>The full list of features is:</p>
<ul>
<li><code>ros1</code> - Enables the <a href="https://docs.rs/roslibrust_ros1/latest/roslibrust_ros1/">roslibrust_ros1</a> backend</li>
<li><code>zenoh</code> - Enables the <a href="https://docs.rs/roslibrust_zenoh/latest/roslibrust_zenoh/">roslibrust_zenoh</a> backend</li>
<li><code>rosbridge</code> - Enables the <a href="https://docs.rs/roslibrust_rosbridge/latest/roslibrust_rosbridge/">roslibrust_rosbridge</a> backend</li>
<li><code>mock</code> - Enables the <a href="https://docs.rs/roslibrust_mock/latest/roslibrust_mock/">roslibrust_mock</a> backend</li>
<li><code>ros2</code> - COMING SOON Enables the <a href="https://docs.rs/roslibrust_ros2/latest/roslibrust_ros2/">roslibrust_ros2</a> backend</li>
<li><code>codegen</code> - Provides access to the <a href="https://docs.rs/roslibrust_codegen/latest/roslibrust_codegen/">roslibrust_codegen</a> crate for generating ROS message types in build.rs.</li>
<li><code>macro</code> - Provides access to the <a href="https://docs.rs/roslibrust_codegen_macro/latest/roslibrust_codegen_macro/">roslibrust_codegen_macro</a> crate for generating ROS message types using a proc-macro.</li>
<li><code>all</code> - Enables all of the above features.</li>
</ul>
<h3 id="pure-rust-type-generation"><a class="header" href="#pure-rust-type-generation">Pure Rust Type Generation</a></h3>
<p>RosLibRust has implemented a full parser and code-generator for ROS message types.
This allows us to generate Rust types from ROS .msg/.srv files at compile time.
The generated types are fully compatible with all RosLibRust backends.
Meaning a ROS1 .msg file can be used with ROS2 and vice versa.</p>
<p>The rosbridge backend support "generic" types with parsing fallbacks, see <a href="https://github.com/RosLibRust/roslibrust/blob/master/roslibrust/examples/generic_message.rs">generic message example</a></p>
<p>A <code>build.rs</code> file can be used to automatically generate Rust types at build time from ROS .msg/.srv files.
See <a href="https://github.com/RosLibRust/roslibrust/tree/master/example_package">example_package</a> for a full example.</p>
<p>A proc-macro is also provided for generating types at compile time, see <a href="https://github.com/RosLibRust/roslibrust/tree/master/example_package_macro">example_package_macro</a> for an example.</p>
<p>This breaks tooling free from needing any ROS installation.</p>
<h3 id="mock-implementation-for-testing"><a class="header" href="#mock-implementation-for-testing">Mock Implementation for Testing</a></h3>
<p>A major challenge for incorporating ROS into larger systems is testing.
Traditionally testing ROS nodes involves either:</p>
<ol>
<li>Breaking all the "ROS Logic" and other logic apart and indpendently testing them.</li>
<li>Launching a full ROS system in a testing environment and interacting with it.</li>
</ol>
<p>The first approach leads to "extra abstraction" and often causes timing and messaging related bugs to be missed.
The second approach is brittle, slow, and often a bottle neck for test times.</p>
<p>RosLibRust provides a mock implementation of ROS for testing that allows deterministic "time traveling" tests.
See <a href="extended_getting_started.html#writing-tests-for-our-node">extended getting started guide</a> for an example.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
