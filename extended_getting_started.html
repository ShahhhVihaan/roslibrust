<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Extended Getting Started - RosLibRust Guides</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RosLibRust Guides</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Inside the roslibrust repository you'll find <a href="https://github.com/RosLibRust/roslibrust/tree/master/example_package">example_package</a>
and <a href="https://github.com/RosLibRust/roslibrust/tree/master/example_package_macro">example_package_macro</a> which serve as good examples of how to integrate roslibrust into a package.</p>
<p>This documentation walks you through how those packages are setup, and how to get started using RosLibRust in your own project.</p>
<p>We recommend using the build.rs approach shown in example_package, as this approach will automatically re-generate your ROS types when the underlying .msg/.srv files are changed.
The macro approach shown in example_package_macro is easier to setup, but can't detect when the underlying .msg/.srv files are changed.
This approach is fine to use if you know your .msg/.srv files are not changing, or if you are ok with manually re-running the macro to generate the types.</p>
<p>This tutorial is written for someone who is new to both Rust and ROS, and assumes no prior knowledge of either.</p>
<h2 id="machine-setup"><a class="header" href="#machine-setup">Machine Setup</a></h2>
<p>RosLibRust is currently only actively tested on Linux, however it should work on Windows and MacOS as well.
If you run into any issues on Windows or MacOS please open an issue on the <a href="https://github.com/RosLibRust/roslibrust/issues">roslibrust github</a>.</p>
<p>The only requirement to building roslibrust is the rust compiler and toolchain.</p>
<p>These are best installed via the instructions on the <a href="https://www.rust-lang.org/tools/install">rust website</a>.</p>
<p>If you are using Linux you can install the rust toolchain by running:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>RosLibRust currently requires a version of the Rust compiler greater than 1.85. This can be checked by running <code>rustc --version</code>.</p>
<p>If you can run this command and see a version greater than 1.85 you're good to move on to the next step.</p>
<p>For actually running the example applications show here you'll need a working ROS installation with the <code>rosbridge_server</code> package.
These instructions show using docker images to run isolated ROS environments.
To exactly follow these instructions you'll need <code>docker engine</code> installed and running on your system.
However, docker can by bypassed if you prefer to directly install a specific version of ROS on your system.</p>
<p>To install docker engine see the <a href="https://docs.docker.com/engine/install/">docker website</a>.</p>
<h2 id="making-an-empty-project"><a class="header" href="#making-an-empty-project">Making an Empty Project</a></h2>
<p>For a longer explanation of this section see the <a href="https://doc.rust-lang.org/book/ch01-03-hello-cargo.html">Hello Cargo</a> section of the Rust Book.</p>
<p>In a folder of your choice run <code>cargo new my_package</code>. This will create a new rust package in the <code>my_package</code> folder.</p>
<p>Cargo (rust's build tool) will automatically generate several files for you in this directory:</p>
<pre><code class="language-bash">my_package
├── .git # A git repository is automatically created for you. You should use git!
├── .gitignore # A gitignore file is automatically created for you with good defaults for a Rust project.
├── Cargo.toml # Controls dependencies and other metadata for your package, equivalent to CMakeLists.txt in C++ or package.xml in ROS
└── src # All the "main" code for your package lives in this folder
    └── main.rs # A starting file with some initial code in it
</code></pre>
<p>Now that we've created this project we can:</p>
<pre><code class="language-bash"># Change into the directory of our new package.
# Once we've done this cargo commands will automatically detect the Cargo.toml file and know
# that they should operate on this package
cd my_package
# This command with both fully compile our package and all its dependencies, and then run the
# resulting executable
cargo run
</code></pre>
<p>If you see <code>Hello, world!</code> printed to the console you're good to move on to the next step.</p>
<h2 id="setting-up-cargotoml"><a class="header" href="#setting-up-cargotoml">Setting Up Cargo.toml</a></h2>
<p>To use roslibrust we need to modify <code>Cargo.toml</code> to add roslibrust as a dependency.</p>
<p>If you're new to Rust you should checkout this chapter in the Cargo Book: <a href="https://doc.rust-lang.org/cargo/guide/dependencies.html">Dependencies</a></p>
<p>An example <code>Cargo.toml</code> is:</p>
<pre><code class="language-toml">[package]
name = "my_package"
version = "0.1.0"
edition = "2021"

# What crates your code needs when built regularly (e.g. `cargo build` or `cargo run`)
[dependencies]
# You will need to specify at least one backend to use with roslibrust, available options are [ros1, rosbridge, zenoh, mock] (ros2 is coming soon)
# You will also need to specify the "codegen" feature, as the generated ROS types rely on features from this module
roslibrust = { version = "0.15", features = ["rosbridge", "codegen"] }
# RosLibRust is built on tokio, and requires a multi-threaded tokio runtime.
# You don't need the "full" tokio feature set, but it is a good starting place
tokio = { version = "1", features = ["full"] }

# What crates your code needs for testing and examples
[dev-dependencies]
# For testing you'll want to use the "mock" backend if you specify it here, it won't affect your production builds
roslibrust = { version = "0.15", features = ["mock"] }
tokio = { version = "1", features = ["test-util"] }

# What crates your code needs to run it's build.rs file
[build-dependencies]
# In build.rs we'll use roslibrust's codegen features to generate Rust types from ROS .msg/.srv files
roslibrust = { version = "0.15", features = ["codegen"] }
</code></pre>
<p>Once we've modified <code>Cargo.toml</code> in this way we can run <code>cargo build</code>,
and we should see Cargo automatically download and compile all the dependencies we've specified.</p>
<p>If this works you're ready to move on to the next step.</p>
<h2 id="setting-up-automatic-rust-ros-type-generation"><a class="header" href="#setting-up-automatic-rust-ros-type-generation">Setting Up Automatic Rust&lt;-&gt;ROS Type Generation</a></h2>
<p>In ROS based systems "nodes" communicate with each other by sending and receiving messages.
Because ROS supports multiple languages (Python, C++, Rust, etc.) a common schema language was needed.
ROS uses calls these custom message definitions "Interfaces" and documents them <a href="https://docs.ros.org/en/rolling/Concepts/Basic/About-Interfaces.html">in the ROS documentation's Basic Concepts section</a>.</p>
<p>To work ergonomically in Rust with these messages we want a corresponding Type in Rust for each message type.
RosLibRust will automatically generate these types for us, and uses the generate types to serialize and deserialize messages as they are sent and received.</p>
<p>To setup automatic generation of these Rust types from ROS interface files, we'll leverage Rust's build.rs feature.
A <code>build.rs</code> file is a special file that Cargo will automatically run before compiling your crate.
This file can be used to generate code, compile native dependencies, or perform any other task needed to build your crate.
Learn more about writing <code>build.rs</code> files <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">in the Cargo Book's build scripts section</a>.</p>
<p>Let's create a copy of build.rs file from <a href="https://github.com/RosLibRust/roslibrust/tree/master/example_package">example_package</a> in our package:</p>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Define our search paths
    // Note: these currently point towards the assets folder in the roslibrust repository,
    // you'll want to point this at the location of your own .msg/.srv files
    let p = vec![
        "../assets/ros2_common_interfaces".into(),
        "../assets/ros2_required_msgs/rcl_interfaces/builtin_interfaces".into(),
    ];

    // Actually invoke code generation on our search paths.
    let (source, dependent_paths) =
        roslibrust::codegen::find_and_generate_ros_messages_without_ros_package_path(p)?;
    // This returns two things:
    // 1) A TokenStream which is the rust code we want to generate
    // 2) A list of paths that if modified would require the code to be regenerated. We use this to inform Cargo
    //    of when to re-run our build script.

    // It is important for build scripts to only output files to OUT_DIR which is an environment variable set by Cargo.
    let out_dir = std::env::var_os("OUT_DIR").unwrap();
    // Name of the file in out_dir we want to write our generated code to
    let dest_path = std::path::Path::new(&amp;out_dir).join("messages.rs");
    // Write the generated code to disk
    std::fs::write(dest_path, source.to_string())?;

    // If we stopped at this point, our code would still work, but Cargo would not know to rebuild
    // our package when a message file changed.
    // Cargo recognizes certain command line strings that build scripts print out:
    for path in &amp;dependent_paths {
        // Tell cargo to re-run our build script if any of these files change
        println!("cargo:rerun-if-changed={}", path.display());
    }

    Ok(())
}</code></pre>
<p>Before this build.rs script can run successfully we'll need to give it some real ROS messages to find.
For this example we'll use some standard ROS2 messages from the <a href="https://github.com/ros2/common_interfaces">ROS2 Common Interfaces</a> repository.</p>
<p>To clone these messages into our package we can run:</p>
<pre><code class="language-bash"># Make sure we're in the root of our package
cd my_package
# Make a folder to hold our messages
mkdir assets
# Clone the common interfaces into that folder
git submodule add https://github.com/ros2/common_interfaces assets/common_interfaces
</code></pre>
<div class="warning">
<p>Warning: ROS messages can refer to other messages in their contents.
For example many messages include a <code>Header</code> message from the <code>std_msgs</code> package.
For code generation to work correctly you must include all the messages you want to generate, AND all the messages that those messages depend on.</p>
</div>
<p>In this specific case, the messages in <code>common_interfaces</code> rely on messages from the <code>builtin_interfaces</code> which is not included in
that same repository. To fix this we'll also need to clone the <code>rcl_interfaces</code> repository which contains the <code>builtin_interfaces</code> package:</p>
<pre><code class="language-bash"># Make sure we're in the root of our package
cd my_package
# Clone the rcl_interfaces repository into our assets folder
git submodule add https://github.com/ros2/rcl_interfaces assets/rcl_interfaces
</code></pre>
<p>Now we just need to modify the <code>search_paths</code> variable in our <code>build.rs</code> file to point at our new messages:</p>
<pre><code class="language-rust ignore">let search_paths = vec![
    "assets/common_interfaces".into(),
    "assets/rcl_interfaces/builtin_interfaces".into(),
];</code></pre>
<p>Now if we run <code>cargo build</code> again we should see Cargo automatically run our <code>build.rs</code> file, and generate our Rust types from the ROS messages.
This won't be immediately obvious from the command line, but we can go look in the <code>target</code> folder of our package to see the generated code.
The generated code will be in <code>target/debug/build/my_package-&lt;some hash of our package&gt;/out/messages.rs</code>.</p>
<p>We can check if the file exists by running:</p>
<pre><code class="language-bash">find -name "messages.rs"
</code></pre>
<p>If this prints out a path to a <code>messages.rs</code> file we're good to move on to the next step.</p>
<h2 id="using-generated-types"><a class="header" href="#using-generated-types">Using Generated Types</a></h2>
<p>Now that we've generated our types we can use them in our code.
Rust luckily has some convenient macros for bringing generated code "into scope" for a crate.</p>
<p>If we open up <code>src/main.rs</code> and add the following line at the top of the file:</p>
<pre><code class="language-rust ignore">include!(concat!(env!("OUT_DIR"), "/messages.rs"));</code></pre>
<p>It will automatically find the generated <code>messages.rs</code> and effectively "copy paste" the contents of that file into our <code>main.rs</code> file.</p>
<p>Breaking down how that line works:</p>
<ul>
<li><code>env!("OUT_DIR")</code> is a macro that expands to the value of the <code>OUT_DIR</code> environment variable. This is set by Cargo and points to the folder where our generated code is located.</li>
<li><code>concat!(...)</code> is a macro that concatenates multiple string literals into a single string literal. In this case we're concatenating the <code>OUT_DIR</code> environment variable with the path to our generated code.</li>
<li><code>include!(...)</code> is a macro that includes the contents of the file at the specified path into the current file. In this case we're including the generated <code>messages.rs</code> file into our <code>main.rs</code> file.</li>
</ul>
<p>Once we've added that line to <code>main.rs</code> all our generated messages will be available to us in the rest of our code.</p>
<p>For this example we'll keep it simple and leave that line in <code>main.rs</code>, but in larger projects it is recommended to move the generated types to either a msgs module or a separate msgs crate in a workspace.</p>
<h2 id="writing-our-first-node"><a class="header" href="#writing-our-first-node">Writing Our First Node</a></h2>
<p>You're now ready to actually write some code that uses RosLibRust!</p>
<p>We're going to start with a basic example of publishing to a topic.</p>
<p>Modify <code>src/main.rs</code> to look like the following:</p>
<pre><code class="language-rust ignore">// Bring generated messages into scope:
include!(concat!(env!("OUT_DIR"), "/messages.rs"));

// Bring in traits we need from roslibrust
use roslibrust::traits::{Publish, Ros, Subscribe};

use std::sync::Arc;
use tokio::sync::Mutex;

// Writing a simple publisher behavior using roslibrust's generic traits
async fn pub_counter(ros: impl Ros, state: Arc&lt;Mutex&lt;u32&gt;&gt;) {
    // This will nicely control the rat our code runs at
    let mut interval = tokio::time::interval(std::time::Duration::from_secs(1));
    // Create a publisher on our topic
    let publisher = ros
        .advertise::&lt;std_msgs::UInt32&gt;("/example_counter")
        .await
        .expect("Could not create publisher!");

    loop {
        // Wait for next tick of our interval timer
        interval.tick().await;

        // Lock our state and read the current value
        let cur_val = *state.lock().await;

        // Publish the current value
        publisher
            .publish(&amp;std_msgs::UInt32 { data: cur_val })
            .await
            .expect("Failed to publish message!");

        // Increment our state
        *state.lock().await += 1;
    }
}

// This macro sets up a basic tokio runtime for us and lets our main function be `async`
#[tokio::main]
async fn main() {
    // Initialize a logger to help with debugging
    env_logger::init();

    // Create a rosbridge client we can use
    let ros = roslibrust::rosbridge::ClientHandle::new("ws://localhost:9090")
        .await
        .expect("Failed to connect to rosbridge!");

    // Create a shared state we can use to track our counter
    let publisher_state = Arc::new(Mutex::new(0));

    // Spawn a new tokio task to run our publisher:
    tokio::spawn(pub_counter(ros, publisher_state));

    // Wait for ctrl_c
    tokio::signal::ctrl_c().await.unwrap();
}</code></pre>
<p>There is a lot to break down in this example, it uses many of the features of Rust, Tokio, and RosLibRust.</p>
<p>Let's start with the high level structure:</p>
<ul>
<li>Our "node" is defined in an <code>async fn</code> this allows to spawn an instance of our node as a new tokio task.</li>
<li>Our node uses <code>impl Ros</code> for the type of the <code>ros</code> parameter. This makes the function generic over any roslibrust backend.</li>
<li>Our main function sets up the dependencies of our node, and then spawns it as a new tokio task to run independently.</li>
<li>We use <code>Arc&lt;Mutex&lt;&gt;&gt;</code> to share mutable state between our tokio tasks.</li>
</ul>
<p>Right now, <strong>why</strong> we did all these things might not be obvious, but it will be once we start wanting to write more complex nodes and when we want to test those nodes.</p>
<h2 id="running-our-node"><a class="header" href="#running-our-node">Running Our Node</a></h2>
<p>So far we've avoided installing any version of ROS at all. This is great since we can write and run our node on a system without any ROS
making our code extremely portable. However, to actually run our node we'll want a ROS system to connect to.</p>
<p>One way to setup this up would be to go through a full ROS installation for either <code>ROS1</code> or <code>ROS2</code>, but the recommended approach for roslibrust is use a ROS installation inside a docker container.
This unfortunately introduces the complexity of docker, but it is a very portable and repeatable way to setup a ROS environment.
Furthermore, it makes it extremely easy to experiment with multiple versions of ROS!</p>
<p>ROS provides docker images for both ROS1 and ROS2 on their <a href="https://hub.docker.com/_/ros">dockerhub page</a>.</p>
<p>RosLibRust is publishing extended docker images that include a rust installation and the <code>rosbridge_server</code> package.
We use these images for developing RosLibRust, and to run our CI tests.</p>
<p>To startup a ROS2 kilted rosbridge server you can run the following commands:</p>
<pre><code class="language-bash"># This will startup a docker container with everything installed in it and drop you into a bash shell inside of the container
docker run -it --network host carter12s/roslibrust-ci-kilted:latest bash
# This will now activate the ROS2 installation inside the container
source /opt/ros/kilted/setup.bash
# This will start up the ROS2 zenoh router, and leave it running in the background
ros2 run rmw_zenoh_cpp rmw_zenohd &amp; disown
# This will start the rosbridge server on the default port of 9090
ros2 run rosbridge_server rosbridge_websocket
</code></pre>
<p>Now in a separate terminal we can run our node.
To be able to actually see what our node is doing we'll enable debug logging with the <code>RUST_LOG</code> environment variable (<a href="https://docs.rs/env_logger/latest/env_logger/">more info on RUST_LOG</a>):</p>
<pre><code class="language-bash">RUST_LOG=debug cargo run
</code></pre>
<p>We should now see our terminal output something like:</p>
<pre><code class="language-txt">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.15s
     Running `/home/carter/roslibrust/target/debug/examples/getting_started_1`
[2025-09-21T19:39:54Z DEBUG roslibrust_rosbridge::client] Starting a stubborn_connect attempt to ws://localhost:9090
[2025-09-21T19:39:54Z DEBUG tungstenite::handshake::client] Client handshake done.
[2025-09-21T19:39:54Z DEBUG roslibrust_rosbridge::client] Starting stubborn_spin
[2025-09-21T19:39:54Z DEBUG roslibrust_rosbridge::client] Advertise got lock on comm
[2025-09-21T19:39:54Z DEBUG roslibrust_rosbridge::comm] Sending advertise: Text("{\"op\":\"advertise\",\"topic\":\"/example_counter\",\"type\":\"std_msgs/UInt32\"}")
[2025-09-21T19:39:54Z DEBUG roslibrust_rosbridge::client] Publish got write lock on comm
[2025-09-21T19:39:54Z DEBUG roslibrust_rosbridge::comm] Sending publish: Text("{\"msg\":{\"data\":0},\"op\":\"publish\",\"topic\":\"/example_counter\",\"type\":\"std_msgs/UInt32\"}")
[2025-09-21T19:39:55Z DEBUG roslibrust_rosbridge::client] Publish got write lock on comm
</code></pre>
<p>We can also confirm everything is working by looking at the output of the rosbridge server in our other terminal.
We should see a "Client connected" message when we startup our node and a "Client disconnected" message when we ctrl+c out of our node.</p>
<pre><code class="language-txt">[INFO] [1758483594.506878271] [rosbridge_websocket]: Client connected. 1 clients total.
[INFO] [1758483600.897845391] [rosbridge_websocket]: Client disconnected. 0 clients total.
</code></pre>
<h2 id="extending-our-node-to-subscribe"><a class="header" href="#extending-our-node-to-subscribe">Extending Our Node to Subscribe</a></h2>
<p>Let's have our node now subscribe to its same topic, and "talk to itself".</p>
<p>Along side our <code>pub_counter</code> let's add a <code>sub_counter</code> function:</p>
<pre><code class="language-rust ignore">async fn sub_counter(ros: impl Ros, state: Arc&lt;Mutex&lt;u32&gt;&gt;) {
    // Create a subscriber on our topic
    let mut subscriber = ros
        .subscribe::&lt;std_msgs::UInt32&gt;("/example_counter")
        .await
        .expect("Could not create subscriber!");

    loop {
        // Wait for next message
        let msg = subscriber.next().await.expect("Failed to get message!");

        // Print the message
        println!("Got message: {}", msg.data);

        // Decrement our state
        *state.lock().await -= 1;
    }
}</code></pre>
<p>And then we'll modify our <code>main</code> function to spawn both behaviors:</p>
<pre><code class="language-rust ignore">// This macro sets up a basic tokio runtime for us and lets our main function be `async`
#[tokio::main]
async fn main() {
    // Initialize a logger to help with debugging
    env_logger::init();

    // Create a rosbridge client we can use
    let ros = roslibrust::rosbridge::ClientHandle::new("ws://localhost:9090")
        .await
        .expect("Failed to connect to rosbridge!");

    // Create a shared state we can use to track our counter
    let shared_state = Arc::new(Mutex::new(0));

    // Spawn a new tokio task to run our publisher:
    tokio::spawn(pub_counter(ros.clone(), shared_state.clone()));

    // Spawn a new tokio task to run our subscriber:
    tokio::spawn(sub_counter(ros, shared_state.clone()));

    // Wait for ctrl_c
    tokio::signal::ctrl_c().await.unwrap();
}</code></pre>
<p>Note: you can now see that we're calling <code>.clone()</code> on our <code>ros</code> and <code>state</code> variables when we spawn our tasks.
For both of these variables, that creates an additional "handle" to the underlying data that can be owned by the new task.
Previously, we we're <code>moving</code> ownership of these variables into our <code>pub_counter</code> task, but now that we want to use them in multiple tasks we need to clone them.</p>
<p>When we run this example (with our docker image still up in the background) we'll see logging like:</p>
<pre><code class="language-txt">[2025-09-21T19:49:30Z DEBUG roslibrust_rosbridge::client] Publish got write lock on comm
[2025-09-21T19:49:30Z DEBUG roslibrust_rosbridge::comm] Sending publish: Text("{\"msg\":{\"data\":0},\"op\":\"publish\",\"topic\":\"/example_counter\",\"type\":\"std_msgs/UInt32\"}")
[2025-09-21T19:49:30Z DEBUG roslibrust_rosbridge::client] Got message: Text("{\"op\": \"publish\", \"topic\": \"/example_counter\", \"msg\": {\"data\": 0}}")
[2025-09-21T19:49:30Z DEBUG roslibrust_rosbridge::client] got message: {"op": "publish", "topic": "/example_counter", "msg": {"data": 0}}
Got message: 0
</code></pre>
<h2 id="writing-tests-for-our-node"><a class="header" href="#writing-tests-for-our-node">Writing Tests for Our Node</a></h2>
<p>Being able to unit and integration test our ROS code is a major feature of RosLibRust.
Let's now ensure our <code>pub_counter</code> and <code>sub_counter</code> behaviors work together in a test.</p>
<p>At the end of <code>main.rs</code> add the following:</p>
<pre><code class="language-rust ignore">// cfg(test) here means that this code is only compile when invoking `cargo test` and doesn't get included in normal builds
#[cfg(test)]
mod test {
    // Bring pub_counter and sub_counter into scope
    use super::*;

    // Tokio will automatically set up an individual async runtime for this test
    #[tokio::test]
    async fn test_pub_sub_counter() {
        // To let us see how long the test takes to run record the current time
        let tick = std::time::SystemTime::now();
        // MAGIC HERE:
        tokio::time::pause();

        // Create a mock ros instance we can use
        // This instance of ROS is unique to this test and won't interfere with any other tests running parallel
        let ros = roslibrust::mock::MockRos::new();

        // Creating separate states so we can inspect individually how they change
        let publisher_state = Arc::new(Mutex::new(0));
        let subscriber_state = Arc::new(Mutex::new(10));

        // Spawn a new tokio task to run our publisher:
        tokio::spawn(pub_counter(ros.clone(), publisher_state.clone()));
        // Spawn a new tokio task to run our subscriber:
        tokio::spawn(sub_counter(ros, subscriber_state.clone()));

        // The publisher and subscriber run for a bit in the background
        tokio::time::sleep(std::time::Duration::from_secs(10)).await;
        let published_count = *publisher_state.lock().await;
        let subscribed_count = *subscriber_state.lock().await;
        // Check the exact number of messages our publisher and subscriber got
        assert_eq!(
            published_count, 10,
            "Published count should be 10, but was {published_count}"
        );
        assert_eq!(
            subscribed_count, 0,
            "Subscribed count should be 0, but was {subscribed_count}"
        );
        // Purely for demonstration purposes, show how long this test takes to run
        let tock = std::time::SystemTime::now();
        println!("Test took in realtime {:?}", tock.duration_since(tick));
    }
}</code></pre>
<p>To understand this test you should first read Tokio's <a href="https://tokio.rs/tokio/topics/testing">testing guide</a>.</p>
<p>The key points are:</p>
<ul>
<li>Tokio's runtime can tell when all futures are block on "time pasing"</li>
<li>When this happens it can determine which future will complete "soonest"</li>
<li>It can then "fast forward" time to that point and poll all futures again</li>
<li>This allows us to deterministically test our code that is driven by time "as fast as possible"</li>
</ul>
<p>We can run this test with <code>cargo test</code> and see the following:</p>
<pre><code class="language-txt">running 1 test
test test::test_pub_counter ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>If we want to see what our test prints to the terminal we can run <code>cargo test -- --no-capture</code> and see the following:</p>
<pre><code class="language-txt">running 1 test
Got message: 0
Got message: 1
Got message: 2
Got message: 3
Got message: 4
Got message: 5
Got message: 6
Got message: 7
Got message: 8
Got message: 9
Test took in realtime Ok(167.189µs)
test test::test_pub_sub_counter ... ok
</code></pre>
<p>This test takes only 167 microseconds to run! This is because Tokio is able to deterministically fast forward time to the point where our futures will complete.</p>
<h2 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h2>
<p>In this tutorial we've shown:</p>
<ul>
<li>How to setup a new crate to use roslibrust</li>
<li>How to write generic ROS behaviors that can be tested in isolation and use any ROS backend</li>
<li>How to run our node against a real ROS system using docker</li>
<li>How to write a simple integration test that uses the mock ROS backend to test multiple behaviors together</li>
</ul>
<p>After this you should have a good understanding of how to use RosLibRust to build and test ROS nodes in rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="quick_getting_started.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="introduction.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="quick_getting_started.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="introduction.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
